options {
    STATIC = false ;
    LOOKAHEAD = 2;
}

PARSER_BEGIN(XWorkParameterParser)
package com.opensymphony.xwork2.parameters;

import com.opensymphony.xwork2.parameters.SimpleCharStream;
import com.opensymphony.xwork2.util.reflection.*;
import java.io.StringReader;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import com.opensymphony.xwork2.parameters.nodes.*;
import com.opensymphony.xwork2.parameters.ParserUtils;
import org.apache.commons.lang.StringUtils;


class XWorkParameterParser {
    public XWorkParameterParser(String paramName) {
        this((new StringReader(paramName)));
    }
}

PARSER_END(XWorkParameterParser)

List<Node> expression():
{
  Node node;
  List<Node> nodes = new ArrayList<Node>();
}
{
     node=subexpression(){
        nodes.add(node);
     }
     (<DOT>  node=subexpression() {
        nodes.add(node);
     })* {
        return nodes;
     }
}

Node subexpression():
{
    Token id;
    Node n;
}
{
      n=collectionExpression() {
        return n;
      }
    | n=indexedExpression() {
        return n;
      }
    | id=<IDENTIFIER> {
        return new IdentifierNode(id.image);
      }
    | <LBRACKET>id=<STRING_LITERAL><RBRACKET> {
        return new IdentifierNode(ParserUtils.getStringLiteral(id.image));
      }
}


CollectionNode collectionExpression():
{
    Token id;
    Object index;
}
{
    id=<IDENTIFIER><LPAREN>index=value()<RPAREN> {
        return new CollectionNode(id.image, index);
    }
}

IndexedNode indexedExpression():
{
    Token id;
    Object index;
}
{
    id=<IDENTIFIER><LBRACKET>index=value()<RBRACKET> {
        return new IndexedNode(id.image, index);
    }
}

Object value():
{
    Token t;
}
{
      t=<STRING_LITERAL> {
        return ParserUtils.getStringLiteral(t.image);
      }
    | t=<INTEGER_LITERAL> {
        return Integer.valueOf(t.image);
      }
    | t=<FLOATING_POINT_LITERAL> {
        return Double.valueOf(t.image);
      }
    | <TRUE> {
        return Boolean.TRUE;
      }
    | <FALSE> {
        return Boolean.FALSE;
      }
}

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

TOKEN :
{
/* Literals */

  < INTEGER_LITERAL: ["0"-"9"] (["0"-"9"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
      | "." (["0"-"9"])+ (<EXPONENT>)?
      | (["0"-"9"])+ <EXPONENT>
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < STRING_LITERAL:
      ("\"" ((~["\"","\\"]) | ("\\" ( ["\\","\""] )))* "\"") |
      ("\'" ((~["\'","\\"]) | ("\\" ( ["\\","\'"] )))* "\'")
  >
|
  < BADLY_ESCAPED_STRING_LITERAL:
      ("\"" (~["\"","\\"])* ("\\" ( ~["\\","\""] ))) |
      ("\'" (~["\'","\\"])* ("\\" ( ~["\\","\'"] )))
  >

/* Reserved Words and Symbols */

| < TRUE: "true" >
| < FALSE: "false" >
| < DOT: "." >
| < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >

/* Identifiers */

| < IDENTIFIER: <LETTER>(<LETTER>|<DIGIT>)* >
|
  < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}
