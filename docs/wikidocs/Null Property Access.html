<html>
    <head>
        <title>XWork - 
         Property Access
        </title>
	    <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body>
	    <table class="pagecontent" border="0" cellpadding="0" cellspacing="0" width="100%" bgcolor="#ffffff">
		    <tr>
			    <td valign="top" class="pagebody">
				    <p>Null property access is a unique feature to XWork that allows object graphs to be created at runtime, saving you the headache of having to pre-initialize them.</p>


<h3><a name="NullPropertyAccess-Simpleobjectgraphs"></a>Simple object graphs</h3>

<p>The feature is quite simple: <b>only</b> during the ParametersInterceptor (for WebWork this would be when http parameters are applied to an action), if an expression being set, such as "document.title", results in a NullPointerException, XWork will attempt to create the null object and try again. So in this case, if "document" is null, WebWork will construct a new Document object so that setting the title will succeed. </p>

<p>This is very useful because it reduces the amount of flattening (and unflattening) you are required to do in your action classes when displaying and setting data from web pages. Rather, you can usually represent the complete object graph by just naming your input fields with well thought-out names (like "document.title"). </p>


<h3><a name="NullPropertyAccess-Collections%2CListsandMaps"></a>Collections, Lists and Maps</h3>

<p>XWork extends this feature even further by offering special support for Collections, Lists and Maps.  If you are providing input for one of these interfaces, XWork can be told what type of objects they will hold and automatically populate them accordingly. What this means is that if you refer to "children0.name", XWork will automatically create a new List to hold the children and also add an empty Child object to that list, so that setting a name on the expression "children0.name" will work correctly. The same goes for maps.  </p>

<p>For this to work you must tell the converters what the objects in the List or Map will be. You do this by specifying "Collection_<b>property</b> = com.acme.CollectionItem" in the conversion properties file. So if you have an action that has a "children" property that should be filled with Child objects, YourAction-conversion.properties should contain:</p>

<div class="code"><div class="codeContent">
<pre class="code-java">Collection_children = come.acme.Child</pre>
</div></div>

<p>For the purposes of conversion, WebWork considers Collections and Lists to be the same.   If the "children" property was declared to be a Collection, a List would be created and used.</p>


<h3><a name="NullPropertyAccess-CustomObjects"></a>Custom Objects</h3>

<p>Advanced users who need to instantiate custom objects will want to extend <b>com.opensymphony.xwork.ObjectFactory</b> and override the buildBean(Class) method.  The default implementation is rather trivial:</p>

<div class="code"><div class="codeContent">
<pre class="code-java"><span class="code-keyword">public</span> <span class="code-object">Object</span> buildBean(<span class="code-object">Class</span> clazz) <span class="code-keyword">throws</span> Exception {
  <span class="code-keyword">return</span> clazz.newInstance();
}</pre>
</div></div>

<p>Once you have your own custom ObjectFactory, you'll need to let XWork know to use it.  You do this by calling ObjectFactory.setObjectFactory(yourObjFactory).</p>

                    			    </td>
		    </tr>
	    </table>
    </body>
</html>
